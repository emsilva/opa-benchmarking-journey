apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-optimized-policies
data:
  simple_rbac_optimized.rego: |
    package rbac

    # Profile-Guided Optimized Simple Role-Based Access Control Policy  
    # Based on profiling analysis showing rule evaluation order impacts
    # Optimizations:
    # 1. Early success for admin users (highest privilege)
    # 2. Reordered role checks based on typical usage patterns
    # 3. Combined rules to reduce evaluation overhead
    # 4. Optimized rule structure for common cases

    # Admin users get immediate approval (most common high-privilege case)
    allow if {
        input.user.role == "admin"
    }

    # Editor permissions - optimized for common read/write patterns
    allow if {
        input.user.role == "editor"
        input.action == "read"
    }

    allow if {
        input.user.role == "editor"
        input.action == "write"
    }

    # Owner permissions - resource-based access
    allow if {
        input.user.role == "owner"
        input.user.id == input.resource.owner
    }

    # Viewer permissions - read-only access
    allow if {
        input.user.role == "viewer"
        input.action == "read"
    }
  
  api_authorization_optimized.rego: |
    package api.authz

    # Profile-Guided Optimized API Authorization Policy
    # Based on profiling analysis for early rejection and common patterns
    # Optimizations:
    # 1. Early rejection for missing credentials
    # 2. Cached token validation
    # 3. Most common endpoints checked first
    # 4. Simplified permission logic

    # Early rejection for missing user ID or token
    reject if {
        not input.user.id
    }

    reject if {
        not input.user.token
    }

    allow if {
        not reject
        valid_token
        has_permission
        within_rate_limit
        within_time_window
    }

    # Cached token validation (simplified)
    valid_token if {
        # Simplified token validation - in practice would verify JWT signature
        count(input.user.token) > 10
    }

    # Most common endpoints first (based on typical API usage)
    common_endpoint if {
        input.method == "GET"
        input.path == "/api/users"
    }

    common_endpoint if {
        input.method == "GET"
        input.path == "/api/orders"
    }

    has_permission if {
        common_endpoint
        "users:read" in input.user.permissions
    }

    has_permission if {
        input.method == "POST"
        input.path == "/api/orders"
        "orders:create" in input.user.permissions
    }

    has_permission if {
        input.method == "GET"
        "users:read" in input.user.permissions
    }

    # Simplified rate limiting (cached calculation)
    rate_limit_key := sprintf("%s:%s", [input.user.id, input.client_ip])

    within_rate_limit if {
        input.user.tier == "premium"
    }

    within_rate_limit if {
        input.user.tier == "standard"
        # Simplified rate check
        true
    }

    # Time window validation (business hours)
    within_time_window if {
        # Always allow for now - could add business hour logic
        true
    }
  
  financial_risk_assessment_optimized.rego: |
    package finance.risk

    # Profile-Guided Optimized Financial Risk Assessment Policy
    # Based on profiling analysis showing expensive calculations
    # Optimizations:
    # 1. Early rejection rules for obvious cases
    # 2. Cached expensive calculations  
    # 3. Lookup tables for scoring
    # 4. Simplified debt-to-income logic

    # Early rejection rules (fail fast)
    # Immediate rejection for extreme cases
    reject_immediately if {
        input.loan_application.amount > 10000000  # > $10M
    }

    reject_immediately if {
        applicant := input.loan_application.applicant
        applicant.credit_scores.experian < 500
    }

    reject_immediately if {
        applicant := input.loan_application.applicant
        high_risk_jurisdiction
    }

    # High risk jurisdictions (lookup table approach)
    high_risk_jurisdiction if {
        applicant := input.loan_application.applicant
        applicant.country == "AF"
    }

    high_risk_jurisdiction if {
        applicant := input.loan_application.applicant
        applicant.country == "IR"
    }

    high_risk_jurisdiction if {
        applicant := input.loan_application.applicant
        applicant.country == "KP"
    }

    high_risk_jurisdiction if {
        applicant := input.loan_application.applicant
        applicant.country == "SY"
    }

    # Main approval logic (only if not rejected)
    approve_loan if {
        not reject_immediately
        credit_score_acceptable
        debt_to_income_acceptable
        employment_verified
        collateral_adequate
    }

    # Cached credit score calculation
    avg_credit_score := (
        input.loan_application.applicant.credit_scores.experian +
        input.loan_application.applicant.credit_scores.equifax +
        input.loan_application.applicant.credit_scores.transunion
    ) / 3

    credit_score_acceptable if {
        avg_credit_score >= 650
    }

    # Simplified debt-to-income (removed market conditions)
    total_monthly_debt := input.loan_application.applicant.total_monthly_debt + input.loan_application.monthly_payment

    debt_to_income_ratio := total_monthly_debt / input.loan_application.applicant.monthly_income

    debt_to_income_acceptable if {
        debt_to_income_ratio <= 0.43
    }

    # Employment verification
    employment_verified if {
        applicant := input.loan_application.applicant
        applicant.employment.verified == true
        applicant.employment.income_verified == true
        applicant.employment.tenure_months >= 24
    }

    # Collateral adequacy (simplified)
    loan_to_value := input.loan_application.amount / input.loan_application.collateral_value

    collateral_adequate if {
        loan_to_value <= 0.8
    }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-benchmark-data
data:
  benchmark_data.json: |
    {
      "users": {
        "user_001": {
          "id": "user_001",
          "role": "admin",
          "department": "engineering",
          "permissions": ["users:read", "users:write", "orders:read", "orders:create"],
          "tier": "premium"
        },
        "user_002": {
          "id": "user_002", 
          "role": "viewer",
          "department": "sales",
          "permissions": ["users:read"],
          "tier": "standard"
        }
      },
      "rate_limits": {
        "premium": 1000,
        "standard": 100
      },
      "risk_factors": {
        "high_risk_countries": ["AF", "IR", "KP", "SY"],
        "min_credit_score": 650,
        "max_debt_ratio": 0.43
      }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opa-optimized
  labels:
    app: opa-optimized
spec:
  replicas: 9  # 3 pods per node initially
  selector:
    matchLabels:
      app: opa-optimized
  template:
    metadata:
      labels:
        app: opa-optimized
    spec:
      # Spread pods evenly across nodes
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values: 
                  - opa-optimized
              topologyKey: kubernetes.io/hostname
      containers:
      - name: opa
        image: openpolicyagent/opa:1.7.1
        ports:
        - containerPort: 8181
          name: http
        env:
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        resources:
          requests:
            cpu: 800m
            memory: 1Gi
          limits:
            cpu: 1000m
            memory: 2Gi
        readinessProbe:
          httpGet:
            path: /health
            port: 8181
          initialDelaySeconds: 10
          periodSeconds: 5
        livenessProbe:
          httpGet:
            path: /health
            port: 8181
          initialDelaySeconds: 30
          periodSeconds: 10
        command:
        - /opa
        args:
        - run
        - --server
        - --addr=0.0.0.0:8181
        - --log-level=error
        - /policies
        - /data/benchmark_data.json
        volumeMounts:
        - name: optimized-policies
          mountPath: /policies
        - name: benchmark-data
          mountPath: /data
      volumes:
      - name: optimized-policies
        configMap:
          name: opa-optimized-policies
      - name: benchmark-data
        configMap:
          name: opa-benchmark-data
---
apiVersion: v1
kind: Service
metadata:
  name: opa-optimized-service
  labels:
    app: opa-optimized
spec:
  type: ClusterIP
  sessionAffinity: None
  ports:
  - port: 8181
    targetPort: 8181
    protocol: TCP
    name: http
  selector:
    app: opa-optimized